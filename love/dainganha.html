<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Thu Hà ❤️</title>
<script>
  // Hiển thị nút sau 10 giây
  setTimeout(() => {
    const btn = document.getElementById("gotoBtn");
    btn.style.display = "block";
  }, 10000); // 10000ms = 10 giây
</script>
<style>
* { margin: 0; padding: 0; }
#app { width: 100vw; height: 100vh; overflow: hidden; }
canvas { display: block; }
</style>
</head>
<body>
<button id="playBtn" style="
  position: fixed; 
  top: 20px; 
  left: 20px;   /* góc trái */
  padding: 10px 20px; 
  font-size: 16px; 
  border-radius: 10px;
  background: #ff1493; 
  color: #fff; 
  border: none; 
  z-index: 9999;
  opacity: 0.8; 
  cursor: pointer;
">Bật nhạc ❤️</button>

  
<a id="gotoBtn" style='display:none'; href="https://lovecodes2.vercel.app/HeartBeatz/myheart.html?id=N4IgtgpgzlCGDm0QC4DaIBqsA2EB2ALgJZ4QAEAbgK5GWDdeGYCbkg8H8gA0IAKoP14BlN9MngAWRQIN4VMoD4NwOe77EABkqAF7xkAHiWFlAiICBOvAAOZQLwbgaJ35AWQDHtYYEK8EWQPCAXwGNpgfF3APBuBv-fmcwpIAEgAHTKwcAHLwVACegKN4aoEh4d6AXPvyAMqwAE6wePDC5FKAtLuWsHFkYID1eGoiAJfSgM67IAC6HERgCEhoHSDFeQQAwgD22KO5KCAAxABmcwAMy3PyYFRQRG7TEAB0YAYAzCAAvkA">Còn nữa ❤️</a>



<style>
  #gotoBtn {
    position: fixed;
    top: 20px;
    right: 20px;
    background-color: #ff1493;
    color: white;
    padding: 10px 16px;
    font-size: 16px;
    font-weight: bold;
    border-radius: 20px;
    text-decoration: none;
    z-index: 9999;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    transition: transform 0.2s, background-color 0.2s;
    cursor: pointer; 
    opacity: 0.5;
  }
  #gotoBtn:hover {
    background-color: #ff66b2;
    transform: scale(1.1);
  }
</style>
<body>
<audio id="bgMusic" src="https://raw.githubusercontent.com/loveha1ndt/iloveha/main/honcayeu.mp3" loop></audio>

<div id="app"></div>

<script type="module">


import * as THREE from "https://esm.sh/three";
import { OrbitControls } from "https://esm.sh/three/examples/jsm/controls/OrbitControls";

function playMusicOnce() {
  const music = document.getElementById("bgMusic");
  if(music.paused) music.play();
}

// Bắt cả click (desktop) và touchstart (mobile)
window.addEventListener("click", playMusicOnce, { once: true });
window.addEventListener("touchstart", playMusicOnce, { once: true });

// Nút bật nhạc cho mobile
const playBtn = document.getElementById("playBtn");
playBtn.addEventListener("click", () => {
  const music = document.getElementById("bgMusic");
  if(music.paused) music.play();
  playBtn.style.display = "none"; // ẩn nút sau khi bật nhạc
});




let w = window.innerWidth, h = window.innerHeight;

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, w/h, 0.001, 1000);
camera.position.set(0,3,24);
camera.lookAt(scene.position);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(w,h);
renderer.setClearColor(0x160016,1);
document.getElementById("app").appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

// ====== Galaxy 50k hạt ======
const count1 = 40000, count2 = 80000;
const geometry = new THREE.BufferGeometry();
const positions = [], sizes = [], shifts = [];

for(let i=0; i<count1+count2; i++){
  let theta=Math.random()*Math.PI*2;
  let phi=Math.acos(Math.random()*2-1);
  let angle=(Math.random()*0.9+0.1)*Math.PI*0.1;
  let strength=Math.random()*0.9+0.1;
  shifts.push(theta,phi,angle,strength);

  let size=Math.random()*1.5+0.5;
  sizes.push(size);

  if(i<count1){
    let r=Math.random()*0.5+9.5;
    let {x,y,z}=new THREE.Vector3().randomDirection().multiplyScalar(r);
    positions.push(x,y,z);
  } else {
    let r=10,R=40;
    let rand=Math.pow(Math.random(),1.5);
    let radius=Math.sqrt(R*R*rand+(1-rand)*r*r);
    let {x,y,z}=new THREE.Vector3().setFromCylindricalCoords(radius,Math.random()*2*Math.PI,(Math.random()-0.5)*2);
    positions.push(x,y,z);
  }
}

geometry.setAttribute("position", new THREE.Float32BufferAttribute(positions,3));
geometry.setAttribute("aSize", new THREE.Float32BufferAttribute(sizes,1));
geometry.setAttribute("aShift", new THREE.Float32BufferAttribute(shifts,4));

const vertexShader = `
attribute float aSize;
attribute vec4 aShift;
uniform float uTime;
varying vec3 vColor;
const float PI=3.141592653589793238;
void main(){
  float d=length(abs(position)/vec3(40.,10.,40.));
  d=clamp(d,0.,1.);
  vec3 color1=vec3(227.,155.,0.);
  vec3 color2=vec3(100.,50.,255.);
  vColor=mix(color1,color2,d)/255.;
  vec3 transformed=position;
  float theta=mod(aShift.x+aShift.z*uTime,PI*2.);
  float phi=mod(aShift.y+aShift.z*uTime,PI*2.);
  transformed+=vec3(sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta))*aShift.w;
  vec4 mvPosition=modelViewMatrix*vec4(transformed,1.0);
  gl_PointSize=clamp(aSize*50.0/-mvPosition.z,1.0,10.0);
  gl_Position=projectionMatrix*mvPosition;
}
`;

const fragmentShader = `
varying vec3 vColor;
void main(){
  float d=length(gl_PointCoord.xy-0.5);
  if(d>0.5) discard;
  gl_FragColor=vec4(vColor,smoothstep(0.5,0.1,d));
}
`;

const material=new THREE.ShaderMaterial({
  vertexShader,
  fragmentShader,
  uniforms:{uTime:{value:0}},
  transparent:true,
  blending:THREE.AdditiveBlending,
  depthTest:false
});

const mesh=new THREE.Points(geometry,material);
mesh.rotation.order="ZYX";
mesh.rotation.z=0.2;
scene.add(mesh);

// ====== 21 Sprite ảnh ======
const imgURLs = [
 "https://i.ibb.co/5hbtJQjy/IMG-2625.jpg",
 "https://i.ibb.co/prwyRFww/IMG-2624.jpg",
 "https://i.ibb.co/tpcbD6c4/IMG-2627.jpg",
 "https://i.ibb.co/twRHKgLk/IMG-2628.jpg",
 "https://i.ibb.co/hRs50fvR/IMG-2629.jpg",
 "https://i.ibb.co/9987CCJW/IMG-2630.jpg",
 "https://i.ibb.co/yvGvY8g/IMG-2634.jpg",
 "https://i.ibb.co/0Rtrm0qK/IMG-2711.jpg",
 "https://i.ibb.co/yBZ9GyyC/IMG-2724.jpg",
 "https://i.ibb.co/nMhm2mVW/IMG-2761.jpg",
 "https://i.ibb.co/JjzBmrwX/IMG-2762.jpg",
 "https://i.ibb.co/fVyWyv79/IMG-2763.jpg",
 "https://i.ibb.co/5XM6kVP7/IMG-2791.jpg",
 "https://i.ibb.co/p6WF06BD/IMG-2792.jpg",
 "https://i.ibb.co/dwbVDk68/IMG-2797.jpg",
 "https://i.ibb.co/6JNvv6v5/IMG-2798.jpg",
 "https://i.ibb.co/Rk8mHy9p/IMG-2799.jpg",
 "https://i.ibb.co/9kVwGgn1/IMG-2801.jpg",
 "https://i.ibb.co/5gpD6txF/IMG-2914.jpg",
 "https://i.ibb.co/prd4NNTf/IMG-2916.jpg"
];

const sprites=[];
const centerRadius=5;
function createTextureWithBorder(image,borderWidth=7,borderRadius=15){
  const canvas=document.createElement('canvas');
  const size=Math.max(image.width,image.height)+borderWidth*2;
  canvas.width=size; canvas.height=size;
  const ctx=canvas.getContext('2d');
  ctx.clearRect(0,0,size,size);
  ctx.beginPath();
  ctx.moveTo(borderRadius+borderWidth,borderWidth);
  ctx.lineTo(size-borderRadius-borderWidth,borderWidth);
  ctx.quadraticCurveTo(size-borderWidth,borderWidth,size-borderWidth,borderRadius+borderWidth);
  ctx.lineTo(size-borderWidth,size-borderRadius-borderWidth);
  ctx.quadraticCurveTo(size-borderWidth,size-borderWidth,size-borderRadius-borderWidth,size-borderWidth);
  ctx.lineTo(borderRadius+borderWidth,size-borderWidth);
  ctx.quadraticCurveTo(borderWidth,size-borderWidth,borderWidth,size-borderRadius-borderWidth);
  ctx.lineTo(borderWidth,borderRadius+borderWidth);
  ctx.quadraticCurveTo(borderWidth,borderWidth,borderRadius+borderWidth,borderWidth);
  ctx.closePath();
  ctx.save(); ctx.clip();
  ctx.drawImage(image,borderWidth,borderWidth,size-borderWidth*2,size-borderWidth*2);
  ctx.restore();
  ctx.strokeStyle="#ff1493";
  ctx.lineWidth=borderWidth;
  ctx.stroke();
  return new THREE.CanvasTexture(canvas);
}

async function loadSprites(urls){
  for(const url of urls){
    try{
      const img = await new Promise((res,rej)=>{
        const i=new Image();
        i.crossOrigin="anonymous"; i.src=url;
        i.onload=()=>res(i); i.onerror=e=>rej(e);
      });
      const texture = createTextureWithBorder(img, 15, 215);
      const mat = new THREE.SpriteMaterial({map:texture, transparent:true, opacity:0.6});
      const sprite = new THREE.Sprite(mat);
      const phi=Math.acos(2*Math.random()-1);
      const theta=Math.random()*Math.PI*2;
      const r=Math.random()*centerRadius;
      sprite.position.set(
        r*Math.sin(phi)*Math.cos(theta),
        r*Math.sin(phi)*Math.sin(theta),
        r*Math.cos(phi)
      );
      sprite.scale.set(1.5,1.5,1);
      sprite.userData.velocity = new THREE.Vector3(
        (Math.random()-0.5)*0.01,
        (Math.random()-0.5)*0.01,
        (Math.random()-0.5)*0.01
      );
      scene.add(sprite);
      sprites.push(sprite);
    }catch(e){console.error("Failed to load image:",url,e);}
  }
}
loadSprites(imgURLs);

// ====== Raycaster hover ======
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let INTERSECTED=null;
function onMouseMove(event){
  mouse.x = (event.clientX / window.innerWidth)*2 - 1;
  mouse.y = -(event.clientY / window.innerHeight)*2 + 1;
}
window.addEventListener('mousemove',onMouseMove,false);

// ====== Hạt lớn 500 ======
const bigCount = 1000;
const bigGeometry = new THREE.BufferGeometry();
const bigPositions=[], bigSizes=[], bigShifts=[];
for(let i=0;i<bigCount;i++){
  let theta=Math.random()*Math.PI*2;
  let phi=Math.acos(Math.random()*2-1);
  let angle=(Math.random()*0.9+0.1)*Math.PI*0.1;
  let strength=Math.random()*0.9+0.1;
  bigShifts.push(theta,phi,angle,strength);
  let size = Math.random()*3 + 5;
  bigSizes.push(size);
  let r=4 + Math.cbrt(Math.random())*5;
  const {x,y,z}=new THREE.Vector3().setFromSphericalCoords(r, phi, theta);
  bigPositions.push(x,y,z);
}
bigGeometry.setAttribute("position", new THREE.Float32BufferAttribute(bigPositions,3));
bigGeometry.setAttribute("aSize", new THREE.Float32BufferAttribute(bigSizes,1));
bigGeometry.setAttribute("aShift", new THREE.Float32BufferAttribute(bigShifts,4));

const bigVertexShader = `
attribute float aSize;
attribute vec4 aShift;
uniform float uTime;
varying vec3 vColor;
const float PI = 3.141592653589793238;
void main(){
  vec3 transformed=position;
  float theta=mod(aShift.x+aShift.z*uTime,PI*2.);
  float phi=mod(aShift.y+aShift.z*uTime,PI*2.);
  transformed+=vec3(sin(phi)*cos(theta),cos(phi),sin(phi)*sin(theta))*aShift.w;
  vec4 mvPosition=modelViewMatrix*vec4(transformed,1.0);
  float d=length(abs(transformed)/vec3(40.,10.,40.));
  d=clamp(d,0.,1.);
  vec3 color1=vec3(227.,155.,0.);
  vec3 color2=vec3(100.,50.,255.);
  vColor=mix(color1,color2,d)/255.;
  gl_PointSize=clamp(aSize*50.0/-mvPosition.z,2.0,50.0);
  gl_Position=projectionMatrix*mvPosition;
}
`;

const bigFragmentShader = `
varying vec3 vColor;
void main(){
  float d=length(gl_PointCoord.xy-0.5);
  if(d>0.5) discard;
  gl_FragColor=vec4(vColor,smoothstep(0.5,0.0,d));
}
`;

const bigMaterial = new THREE.ShaderMaterial({
  vertexShader: bigVertexShader,
  fragmentShader: bigFragmentShader,
  uniforms:{uTime:{value:0}},
  transparent:true,
  blending:THREE.AdditiveBlending,
  depthTest:false
});

const bigMesh = new THREE.Points(bigGeometry,bigMaterial);
scene.add(bigMesh);




// ====== Trái tim trung tâm nhỏ như 1 hạt ======
function createTinyHeartGeometry(){
  const shape = new THREE.Shape();
  const N = 100;
  for(let i=0;i<=N;i++){
    const t = i/N * Math.PI*2;
    const x = 16*Math.pow(Math.sin(t),3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    if(i===0) shape.moveTo(x/80, y/80); // scale cực nhỏ
    else shape.lineTo(x/80, y/80);
  }

  const geometry = new THREE.ExtrudeGeometry(shape,{
    depth:0.22,           // cực mỏng
    bevelEnabled:true,
    bevelSegments:2,
    steps:1,
    bevelSize:0.1,
    bevelThickness:0.1,
    curveSegments:20
  });

  geometry.computeVertexNormals();
  return geometry;
}

const heartMaterial = new THREE.MeshBasicMaterial({
  color: 0xff6a00,   // cam sáng, cùng tông với hạt nhỏ
    transparent: true,
    opacity: 1,      // có thể chỉnh từ 0.6 → 1.0
    side: THREE.DoubleSide,
    blending: THREE.AdditiveBlending  // cho cảm giác phát sáng
    
});

const heartMesh = new THREE.Mesh(createTinyHeartGeometry(), heartMaterial);
heartMesh.scale.set(4,6,4);       // scale chuẩn, rất nhỏ
heartMesh.position.set(0,0,0);    // trung tâm galaxy
heartMesh.renderOrder = -1;
depthTest: true;
scene.add(heartMesh);

// Nếu muốn nhịp đập nhỏ:
const heartClock = new THREE.Clock();
function updateHeart(){
  const t = heartClock.getElapsedTime();
  const baseScale = 1;
  const scale = baseScale + Math.sin(t*3)*0.8;  // nhịp rất nhỏ
  heartMesh.scale.set(scale, scale, scale);

}

// Trong render loop gọi updateHeart()



// ====== Render Loop ======
const clock = new THREE.Clock();
function render(){
  const time = clock.getElapsedTime();
  material.uniforms.uTime.value = time;
  bigMaterial.uniforms.uTime.value = time;

  mesh.rotation.y = time*0.01;
  bigMesh.rotation.y = time*0.005;

  sprites.forEach(sprite=>{
    sprite.position.add(sprite.userData.velocity);
    if(sprite.position.length()>centerRadius) sprite.userData.velocity.multiplyScalar(-1);
    if(sprite!==INTERSECTED){sprite.scale.set(1,1,1); sprite.material.opacity=0.6;}
  });

  raycaster.setFromCamera(mouse,camera);
  const intersects=raycaster.intersectObjects(sprites);
  if(intersects.length>0){
    const sprite=intersects[0].object;
    INTERSECTED=sprite;
    sprite.scale.set(2,2,2);
    sprite.material.opacity=1;
    sprite.renderOrder = 999;
  } else INTERSECTED=null;

  updateHeart();

  controls.update();
  renderer.render(scene,camera);
  requestAnimationFrame(render);
}
render();

window.addEventListener("resize",()=>{
  w=window.innerWidth; h=window.innerHeight;
  renderer.setSize(w,h);
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
});
</script>
</body>
</html>



